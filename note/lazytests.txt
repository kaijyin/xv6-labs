lazytests
测试一二中会先sbrk一段很大的空间,然而由于要满足内核页表映射用户页表,用户空间大小只能在PILC以下
故会失败,所以由4096*4096*4096缩小为10*4096*4096
测试三,要让缺页trap异常中申请页面失败时,终止进程
即oom错误,同样由于用户空间大小有限,而且测试每次取的sbrk空间间隙太大,空闲物理页是充足的,无法触发缺页申请页面失败,
所以间隙从4096*4096减小到4096,成功触发oom异常

usertests中的sbrkfail
bug1:触发kernel的缺页异常
solve:按理说xv6是直接映射的物理空间,是不会触发缺页异常的,
但是由于内核页表映射用户页表物理空间,锁定出错位置,在缺页为用户页表添加物理空间映射时,同时为内核页表添加相同映射.
同理,为read,write,pipe,sbrk等其他物理页表变换的位置添加内核页表的映射

bug2:进程缺页终止后,页表在被回收时触发freewalk panic异常
solve:对代码分析6小时后得出结论,p->sz>va 而不是>= 麻了

bug3:和bug2一样的,相关的判断都得改

usertests中的copyin
bug:直接暂停运行,可能是死锁了
solve:发现是在测攻击,va舍得很特殊,这里是因为write/read时触发va太大,本来超过进程sz就会退出,
但由于溢出,得到va+n的值比p->sz小,成功进入umalloc函数申请物理页map,但va太大,导致错误.
